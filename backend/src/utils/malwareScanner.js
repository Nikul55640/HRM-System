import fs from 'fs';
import path from 'path';
import { promisify } from 'util';

const readFile = promisify(fs.readFile);

// Quarantine directory for infected files
const quarantineDir = path.join(process.env.UPLOAD_PATH || './uploads', 'quarantine');

// Ensure quarantine directory exists
if (!fs.existsSync(quarantineDir)) {
  fs.mkdirSync(quarantineDir, { recursive: true });
}

/**
 * Scan a file for malware
 * @param {string} filePath - Path to the file to scan
 * @returns {Promise<Object>} Scan result
 */
const scanFile = async (filePath) => {
  try {
    // Check if file exists
    if (!fs.existsSync(filePath)) {
      throw new Error('File not found');
    }

    // Get file stats
    const stats = fs.statSync(filePath);
    const fileSize = stats.size;

    // Basic validation checks
    const validationResult = await performBasicValidation(filePath, fileSize);
    if (!validationResult.isClean) {
      return validationResult;
    }

    // Check if ClamAV is available
    const clamAvAvailable = await isClamAvAvailable();

    if (clamAvAvailable) {
      // Use ClamAV for scanning
      return await scanWithClamAv(filePath);
    }
    // Fallback to basic validation only
    console.warn('ClamAV not available. Using basic validation only.');
    return {
      isClean: true,
      scanner: 'basic-validation',
      message: 'File passed basic validation (ClamAV not available)',
      timestamp: new Date(),
    };
  } catch (error) {
    throw new Error(`Malware scan failed: ${error.message}`);
  }
};

/**
 * Perform basic file validation
 * @param {string} filePath - Path to the file
 * @param {number} fileSize - File size in bytes
 * @returns {Promise<Object>} Validation result
 */
const performBasicValidation = async (filePath) => {
  try {
    // Read first few bytes to check for suspicious patterns
    const buffer = await readFile(filePath);
    const header = buffer.slice(0, 512);

    // Check for common malware signatures (basic patterns)
    const suspiciousPatterns = [
      // Executable patterns
      Buffer.from([0x4d, 0x5a]), // MZ header (Windows executable)
      Buffer.from([0x7f, 0x45, 0x4c, 0x46]), // ELF header (Linux executable)
      // Script patterns that shouldn't be in documents
      Buffer.from('<?php'),
      Buffer.from('<script'),
      Buffer.from('eval('),
      Buffer.from('exec('),
    ];

    for (const pattern of suspiciousPatterns) {
      if (header.includes(pattern)) {
        return {
          isClean: false,
          scanner: 'basic-validation',
          threat: 'Suspicious file pattern detected',
          message: 'File contains potentially malicious content',
          timestamp: new Date(),
        };
      }
    }

    // Check file size (files over 50MB are suspicious for documents)
    const maxSuspiciousSize = 50 * 1024 * 1024; // 50MB
    if (buffer.length > maxSuspiciousSize) {
      return {
        isClean: false,
        scanner: 'basic-validation',
        threat: 'Suspicious file size',
        message: 'File size exceeds reasonable limits for document types',
        timestamp: new Date(),
      };
    }

    return {
      isClean: true,
      scanner: 'basic-validation',
      message: 'File passed basic validation',
      timestamp: new Date(),
    };
  } catch (error) {
    throw new Error(`Basic validation failed: ${error.message}`);
  }
};

/**
 * Check if ClamAV is available
 * @returns {Promise<boolean>} True if ClamAV is available
 */
const isClamAvAvailable = async () => {
  try {
    await import('clamscan');
    return true;
  } catch (error) {
    return false;
  }
};

/**
 * Scan file with ClamAV
 * @param {string} filePath - Path to the file
 * @returns {Promise<Object>} Scan result
 */
const scanWithClamAv = async (filePath) => {
  try {
    const ClamModule = await import('clamscan');
    const NodeClam = ClamModule.default || ClamModule;

    // Initialize ClamAV scanner
    const clamscan = await new NodeClam().init({
      removeInfected: false,
      quarantineInfected: false,
      scanLog: null,
      debugMode: false,
      clamdscan: {
        host: process.env.CLAMAV_HOST || 'localhost',
        port: process.env.CLAMAV_PORT || 3310,
        timeout: 60000,
      },
      preference: 'clamdscan',
    });

    // Scan the file
    const { isInfected, viruses } = await clamscan.isInfected(filePath);

    if (isInfected) {
      return {
        isClean: false,
        scanner: 'clamav',
        threat: viruses.join(', '),
        message: `Malware detected: ${viruses.join(', ')}`,
        timestamp: new Date(),
      };
    }

    return {
      isClean: true,
      scanner: 'clamav',
      message: 'File is clean',
      timestamp: new Date(),
    };
  } catch (error) {
    console.error('ClamAV scan error:', error.message);
    return {
      isClean: true,
      scanner: 'basic-validation-fallback',
      message: 'ClamAV scan failed, using basic validation',
      warning: error.message,
      timestamp: new Date(),
    };
  }
};

/**
 * Quarantine an infected file
 * @param {string} filePath - Path to the infected file
 * @returns {Promise<string>} Path to quarantined file
 */
const quarantineFile = async (filePath) => {
  try {
    const fileName = path.basename(filePath);
    const timestamp = Date.now();
    const quarantinedFileName = `${timestamp}-${fileName}`;
    const quarantinedPath = path.join(quarantineDir, quarantinedFileName);

    // Move file to quarantine
    fs.renameSync(filePath, quarantinedPath);

    // Create metadata file
    const metadataPath = `${quarantinedPath}.json`;
    const metadata = {
      originalPath: filePath,
      quarantinedAt: new Date().toISOString(),
      fileName,
    };
    fs.writeFileSync(metadataPath, JSON.stringify(metadata, null, 2));

    console.log(`File quarantined: ${quarantinedPath}`);

    return quarantinedPath;
  } catch (error) {
    throw new Error(`Failed to quarantine file: ${error.message}`);
  }
};

/**
 * Middleware to scan uploaded files
 * @param {Object} req - Express request
 * @param {Object} res - Express response
 * @param {Function} next - Express next function
 */
const scanUploadedFile = async (req, res, next) => {
  try {
    // Check if file was uploaded
    if (!req.file) {
      return next();
    }

    const filePath = req.file.path;

    // Scan the file
    const scanResult = await scanFile(filePath);

    if (!scanResult.isClean) {
      // Quarantine the infected file
      await quarantineFile(filePath);

      // Return error response
      return res.status(400).json({
        success: false,
        error: {
          code: 'MALWARE_DETECTED',
          message: scanResult.message,
          threat: scanResult.threat,
          timestamp: scanResult.timestamp,
        },
      });
    }

    // File is clean, attach scan result to request
    req.scanResult = scanResult;
    next();
  } catch (error) {
    console.error('Malware scan error:', error);
    // On scan error, reject the upload for security
    return res.status(500).json({
      success: false,
      error: {
        code: 'SCAN_ERROR',
        message: 'Unable to scan file for security threats',
        details: error.message,
      },
    });
  }
};

/**
 * Clean up quarantine directory (remove files older than 30 days)
 */
const cleanupQuarantine = () => {
  try {
    const files = fs.readdirSync(quarantineDir);
    const now = Date.now();
    const thirtyDays = 30 * 24 * 60 * 60 * 1000;

    files.forEach((file) => {
      const filePath = path.join(quarantineDir, file);
      const stats = fs.statSync(filePath);
      const fileAge = now - stats.mtimeMs;

      if (fileAge > thirtyDays) {
        fs.unlinkSync(filePath);
        console.log(`Cleaned up quarantined file: ${file}`);
      }
    });
  } catch (error) {
    console.error('Error cleaning up quarantine:', error);
  }
};

// Schedule quarantine cleanup daily
setInterval(cleanupQuarantine, 24 * 60 * 60 * 1000);

export {
  scanFile,
  scanUploadedFile,
  quarantineFile,
  cleanupQuarantine,
  performBasicValidation,
  isClamAvAvailable,
  quarantineDir,
};
